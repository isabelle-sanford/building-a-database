
Questions / thoughts: 
Do I need to care about pointers? YUP
How do the driver / sql packages interact with what I need to do? Do I need to implement the functions in driver? 




Package stuff
- sync will be useful for concurrency

Useful tutorial stuff:
https://go.dev/doc/effective_go
https://pkg.go.dev/std standard library
https://go.dev/ref/spec language spec
https://go.dev/doc/tutorial/call-module-code modules / tutorial

Package driver defines interfaces for drivers to implement - probably what I want / equivalent of JDBC? 
https://pkg.go.dev/database/sql/driver@go1.19.4
https://github.com/golang/go/wiki/SQLDrivers
https://pkg.go.dev/database/sql@go1.19.4
https://pkg.go.dev/database/sql@go1.19.4
https://github.com/golang/go/wiki/SQLInterface

for now going for just the block / page things, figure out how to wrap into JDBC-equivalent later 

probs do NOT want syscall bc it's system-specific stuff - os is better

might use unsafe? 

SO on reading and writing bytes - 
I could use a Reader for reading and a Writer for writing but that's creating a reading/writing object each time when I'd rather just have a wrapper for the bytes overall (like java bytebuffer) or access directly via slices (which ... should work?)
Question with slices is how to convert from some bytes to an int ? is there a parseInt for bytes? 
ok yes but I'm still making a reader each time... is that ok? 

something something changing stuff inside functions 
how do I make it so that the write actually sticks? 

APPARENTLY I just needed to give it *Page instead of Page >:( but hey it works now!!

12/21 8pm - Page works, questions remaining:
How to pass blocksize as a constant that you can specify the size of an array with 
How to allow multiple constructors (/ functions) with the same name but different arguments
Is making a [BLOCKSIZE]byte actually a page from the OS? How do I know / trust that? 
Also is blocksize in bits or bytes - 4096 bits or 4096 bytes? 


Important: need to get block / int sizes from single source eventually - how to pull between pages? 
ERROR HANDLING EVERYWHERE
REMEMBER TO CLOSE FILES <- defer thingy?

FIXED: Error - if you write a page to a block in a file, trying to read from any subsequent block which has not been written to results in "Failed to read block in file: EOF" error and then a correct printing of the block contents (i.e. all 0s)
FIXED: EOF error was still returning the empty page that was inserted initially. Now returns both page and err bool. 

Problem: read / write functions are only allowed to be written to/from slices, not arrays, which means my page.contents is currently a slice, which - as far as I can tell is worse? Even though I can set capacity at 4096? 

probably need to reopen vsc in this folder and open old go stuff in a separate window to get it to play nice and not have to use terminal

just declaring everything as int64 rather than int, rather than trying to pull which the computer uses at baseline 

the question of where I go next also kinda depends on how easy it will be to build buffer pools and concurrency in later - if it's a real pain then could just do now? maybe just look at ch 4 / 5 to see how hard implementation would be

12/21 11:30pm SUMMARY--------
Research: 
Go - refresher on basic structs with methods, slices and arrays, syntax, basic maps, pointers. Probably need more work with slices/arrays, and DEFINITELY more with pointers.
Packages - os and io will be vital packages, bytes and encoding/binary are helpful, sync will be important if/when concurrency
DBs/etc - much stronger understanding of the whole filemanager system (of course) as well as exactly how buffers work and interact with files and so on. (I ended up not actually using any buffers really, but I tried for a whiile.)
FIXED - turned out to be a problem in fileMgr.appendNewBlock() where it was doing Write(b) and overwriting the first block as empty post-writing (or something? still not super clear but changing to f.WriteAt worked)

Had temporary error where on creating log files 0-10, they'd print fine, and then creating additionaly 36-70, the print would work for the first several(?) records (i.e. 170, 169, ...) but somewhere in the middle (like around 155) the prints would only happen for every other record, and skip the rest. Can't recreate now, so hopefully it's fine? 

Coding: 
Created BlockId, Page, and FileManager objects, all of which are (mostly?) functional. 

Struggles: 
- Figuring out how to find the size of int on a particular machine and then deciding to use int64 everywhere rather than having to do some casting for various reasons. 
- Trying very hard to insert a given byte-slice into a particular spot in my byte-array with buffers etc, and eventually just doing it with a for loop through the slice.
- Actually writing to the array and that lasting outside the function requires the method to be on *Page rather than Page so you're changing the actual values, or something. Pointers are bad.  
- Figuring out how to access variables/etc from other files.
- Writing, appending, and reading a file - can't just use Open() for that since you don't get write perms for just that, need to specify in OpenFile() function. 
- A write-to-page operation will not overwrite whatever was on the page previously (or possibly won't overwrite iff it's 0? not sure yet), so need to create new pages each time I want to pull a new thing rather than be able to reuse the same page (which isn't that much of a problem but does seem like it won't work with the buffer pool optimizations)


Later improvements / optimizations / things that are still bad:
- There's only one constructor for Page, and I don't know how to make two functions with the same name that take different arguments. 
- The contents of Page are a slice of capacity blocksize, rather than an array as I'd prefer. There are several constraints here, but one is that the constructor is passing the blocksize but using that as the size of the array is an error because the argument isn't constant. 
- Files closing should use the defer keyword, probably? 
- I don't know what the permission integers mean for when I create/open a file in getFile(), and it's hard-coded
- Page can read/write bytes and integers but should add strings. 
- Testing is ok on page.go but a little messy / uncommented / unclear from cmd line. Testing in filemanager could use serious improvement. 
- I don't understand the format in which it prints numbers by default (i.e. 1029388 is [152 212 125])
- Need to capitalize functions which will be needed outside of this package (and kinda decide how packaging will work / if I want more than one)
X (DONE) Making the initial dbDirectory / how to tell if new for file manager is a little confusing since it's not a distinct struct. (should it be?)
- WAY MORE ERROR CHECKING EVERYWHERE (esp in page.go, file manager I was forced to add them more to figure out what was happening)
- make sure page to be written to is fully overwrote
X (DONE) Debug EOF error when reading an unwritten-to block that's after a written-to one


Other stuff - 

Writing to pages is done via a for loop assigning each byte in the input to its corresponding index in the array. There may or may not be a better way to do this using buffers. (As far as I could tell, there were no buffers that had read, write, and seek functionality - at most two of the three.)

The requester must know whether they want an int or bytes; if they ask for bytes when it's an int, it'll interpret that int as the length of the byte-string and potentially cause a lot of problems. This should be fine, I think? 

Up next: 
Debug file manager a little more and add more thorough testing. 
Look at exercises for chapter 3 and decide if any would be helpful to implement. 
Read chapter 6 carefully, and try to implement. 
Optional: Try to add in basics of ch 4 (and maybe 5), if those seem like they'll be incredibly hard to add in later. 


12/31/22 12pm
starting 12pm, with recpage.go (trying to implement ch 6)

todo: 
TEST SCHLAYOUT FUNCS
recordPage is. real tricky without having done the transaction manager
Question - get/set funcs? or no? 
COMMENT EVERYTHINGGGGG
feeling like recpage in particular is a bit too java-like (but I don't understand well enough to fix bc I haven't done ch 3-4 yet) (sigh)
might just need to do those proper, since hard to even test without that 
but hey then there's concurrency! 
need to update go
having duplicate setInt and setString for everything feels... there seems like there should be a better way in Go (esp as you add more types...)
did recordpage just copying, but doing tablescan just with the API and seeing how I do
might need to go back and make a filemanager object
2:30pm checking how well I did with TableScan (feel pretty good, it was mostly transferring over from RecordPage actually?)
can almost certainly switch blknum back from int64 in BlockId sigh
conveniently this author also provides v good tests! 
3:30pm finish ch 6 stuff, at least in theory 
want to implement at least a bit more complexity than in SimpleDB, see problems below / try spanned records maybe? variable length? 
kind of want to just do ch 7 but also kind of should go back and do earlier chapters 
ALSO THEY TRIED TO DELIVER BOOK BUT FAILED FOR UNSPECIFIED REASONS SIGHHHH
okay gonna go back and actually make a FileMgr object 
need to re-test filemanager.go (also fix its problems bc there are a couple sighh)
LOOK AT OS PACKAGE FUNCTION Sync(): Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk. 
(also maybe syscallconn?)
really need to figure out perms for making files
ok done! but untested, and really not sure how pathname for dbDir is gonna work ngl
? how to have testing funcs in each package that aren't technically 'main' - just name test()? ..probs that

TODO:
X fix tests for filemanager.go 
X start filling in memmgr.go 
- comment a bunch of stuff 
- update version of go
- get simpledb code thingy? 

4:30pm start tests for filemanager.go 
AND DONE :D 
(except for the weird EOF error from before)
and fixed that! 

5pm starting on ch 4 ig 
made addLogPage() func (still can't do func override things)

6pm gotta leave, need to figure out what boundary is but otherwise LogMgr is pretty set


12/31/22 11pm

maybe I should just convert all ints to int64 >:(
12am - finished(?) log manager, I think - still needs testing though
figure out how to do null values for structs? if possible? 
12:30am - first attempt at buffer / buffer manager
this nil stuff is VERY ANNOYING
buffermanager is functional except for:
- the waiting for an open pin thing 
- trying to return either a buffer or nil

feels like FileMgr, LogMgr, BufferMgr shouldn't be structs since there's 1 per db anyway

12/31/22 SUMMARY--------
Progress:
- finished recpage and wrote tableScan as much as I could without ch 4/5 
- made a FileMgr struct from ch 3 (which is probably good, even though it seems maybe too OOP?); fixed tests to work with that (+ fixed EOF error)
- went back to ch 4 (memory management) and did LogMgr, with a decent amount of BufferMgr done as well 

Struggled with: 
- trying to do ch 6 without having ch 4/5 actually done 
- pathname / directory creation stuff (for creating filemgr)
- the append method for LogMgr hurt my head for a while 
- really want to be able to return either struct or nil (or whatever falsy val) but can't, might have to just do errors everywhere? (might be able to just do nil pointers?)
- int vs int64 conversions are annoying 

Questions:
- how do I have test functions (like you'd put in the main() in a java program) that don't run unless I specify (but I can specify that, from cmd line)? 
- Can I return either a falsy value or a struct in a given function? 
- How does waiting / delay stuff work in Go? 
- Is there a difference between creating a [4096]byte vs make([]byte, 4096) in usage / optimization, if I never add more to the slice than that capacity? (If not, can I pass an integer as a constant that can make an array of that size?)
- If I have a [4096]byte, is that / how do I know that that's an actual single page from the OS? 
- What is the sql interface in Go and how do I use it? 

Todo: 
- BufferMgr, waiting functionality 
- BufferMgr, null vs buffer returning (also one in LogMgr too)
- WRITE TESTS for memmgr.go 
- update version of Go 
- actually open the simpledb code 
- read ch 5 carefully

Parking lot: 
- comment EVERYTHING way more 
- way more error checking 
- improve tests
- things to check out: os Sync, syscallconn; io 
- figure out how perms for creating files work
- optimize ch 6 stuff (e.g. spanned records, variable length, etc)
- go back and figure out the string stuff for ch 3
- consider un-struct-ing BufferMgr, LogMgr, FileMgr
- write tests for ch 6 stuff
- make sure that writeBlock actually fully overwrites whatever was on the page previously
- use arrays instead of slices? perhaps? 
- optimize ch 4/5 stuff (only AFTER basics are done tho)
- think about returning vs updating the thing passed in (since returning is probably by value) (but slices are passed by reference!)

bedtime now, more tomorrow! (1:10am, 1/1/23!!)
(or I could stay up looking at the 245 stuff for another 45 minutes) (sigh)
nov 16-21 is NOT gone through (stopped at topic 9, nov 7-14, and some of that is open but not looked through either (struct size, pointers tree, sizeof / array slice size allocations))


1/1/2023 1:15pm
Starting with making tests for logMgr
added get/set string to pages (NEED TO TEST) 
I still don't really understand the maxLength thing for strings on pages - I guess it's basically for different charset encodings. For now leave as is and assume all are ascii (thus all strings must be same length)?
pointers sigh
need WAYYY better test print thingies that actually say what each part is doing (also tbf, have the prints for inside the Page stuff be tested there, so it doesn't clutter up tests of eg logmgr)
having append be pointer makes currblock stay 
writing (reading?) SPECIFICALLY block 0 fails
write works and reads correctly inside flush but not outside
why is everything doubled when it gets written down in binary (or maybe just ints?)

5:30pm still struggling with error above: the writing of block 0 to the file (via flush) is local and does not survive outside the scope. Writing and reading any blocks 1+ does not have this problem and saves pages to the file perfectly fine. 
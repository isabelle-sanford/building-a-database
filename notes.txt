
Questions / thoughts: 
Do I need to care about pointers? YUP
How do the driver / sql packages interact with what I need to do? Do I need to implement the functions in driver? 




Package stuff
- sync will be useful for concurrency

Useful tutorial stuff:
https://go.dev/doc/effective_go
https://pkg.go.dev/std standard library
https://go.dev/ref/spec language spec
https://go.dev/doc/tutorial/call-module-code modules / tutorial

Package driver defines interfaces for drivers to implement - probably what I want / equivalent of JDBC? 
https://pkg.go.dev/database/sql/driver@go1.19.4
https://github.com/golang/go/wiki/SQLDrivers
https://pkg.go.dev/database/sql@go1.19.4
https://pkg.go.dev/database/sql@go1.19.4
https://github.com/golang/go/wiki/SQLInterface

for now going for just the block / page things, figure out how to wrap into JDBC-equivalent later 

probs do NOT want syscall bc it's system-specific stuff - os is better

might use unsafe? 

SO on reading and writing bytes - 
I could use a Reader for reading and a Writer for writing but that's creating a reading/writing object each time when I'd rather just have a wrapper for the bytes overall (like java bytebuffer) or access directly via slices (which ... should work?)
Question with slices is how to convert from some bytes to an int ? is there a parseInt for bytes? 
ok yes but I'm still making a reader each time... is that ok? 

something something changing stuff inside functions 
how do I make it so that the write actually sticks? 

APPARENTLY I just needed to give it *Page instead of Page >:( but hey it works now!!

12/21 8pm - Page works, questions remaining:
How to pass blocksize as a constant that you can specify the size of an array with 
How to allow multiple constructors (/ functions) with the same name but different arguments
Is making a [BLOCKSIZE]byte actually a page from the OS? How do I know / trust that? 
Also is blocksize in bits or bytes - 4096 bits or 4096 bytes? 


Important: need to get block / int sizes from single source eventually - how to pull between pages? 
ERROR HANDLING EVERYWHERE
REMEMBER TO CLOSE FILES <- defer thingy?

Error: if you write a page to a block in a file, trying to read from any subsequent block which has not been written to results in "Failed to read block in file: EOF" error and then a correct printing of the block contents (i.e. all 0s)
FIXED: EOF error was still returning the empty page that was inserted initially. Now returns both page and err bool. 

Problem: read / write functions are only allowed to be written to/from slices, not arrays, which means my page.contents is currently a slice, which - as far as I can tell is worse? Even though I can set capacity at 4096? 

probably need to reopen vsc in this folder and open old go stuff in a separate window to get it to play nice and not have to use terminal

just declaring everything as int64 rather than int, rather than trying to pull which the computer uses at baseline 

the question of where I go next also kinda depends on how easy it will be to build buffer pools and concurrency in later - if it's a real pain then could just do now? maybe just look at ch 4 / 5 to see how hard implementation would be

12/21 11:30pm SUMMARY--------
Research: 
Go - refresher on basic structs with methods, slices and arrays, syntax, basic maps, pointers. Probably need more work with slices/arrays, and DEFINITELY more with pointers.
Packages - os and io will be vital packages, bytes and encoding/binary are helpful, sync will be important if/when concurrency
DBs/etc - much stronger understanding of the whole filemanager system (of course) as well as exactly how buffers work and interact with files and so on. (I ended up not actually using any buffers really, but I tried for a whiile.)

Coding: 
Created BlockId, Page, and FileManager objects, all of which are (mostly?) functional. 

Struggles: 
- Figuring out how to find the size of int on a particular machine and then deciding to use int64 everywhere rather than having to do some casting for various reasons. 
- Trying very hard to insert a given byte-slice into a particular spot in my byte-array with buffers etc, and eventually just doing it with a for loop through the slice.
- Actually writing to the array and that lasting outside the function requires the method to be on *Page rather than Page so you're changing the actual values, or something. Pointers are bad.  
- Figuring out how to access variables/etc from other files.
- Writing, appending, and reading a file - can't just use Open() for that since you don't get write perms for just that, need to specify in OpenFile() function. 
- A write-to-page operation will not overwrite whatever was on the page previously (or possibly won't overwrite iff it's 0? not sure yet), so need to create new pages each time I want to pull a new thing rather than be able to reuse the same page (which isn't that much of a problem but does seem like it won't work with the buffer pool optimizations)


Later improvements / optimizations / things that are still bad:
- There's only one constructor for Page, and I don't know how to make two functions with the same name that take different arguments. 
- The contents of Page are a slice of capacity blocksize, rather than an array as I'd prefer. There are several constraints here, but one is that the constructor is passing the blocksize but using that as the size of the array is an error because the argument isn't constant. 
- Files closing should use the defer keyword, probably? 
- I don't know what the permission integers mean for when I create/open a file in getFile(), and it's hard-coded
- Page can read/write bytes and integers but should add strings. 
- Testing is ok on page.go but a little messy / uncommented / unclear from cmd line. Testing in filemanager could use serious improvement. 
- I don't understand the format in which it prints numbers by default (i.e. 1029388 is [152 212 125])
- Need to capitalize functions which will be needed outside of this package (and kinda decide how packaging will work / if I want more than one)
X (DONE) Making the initial dbDirectory / how to tell if new for file manager is a little confusing since it's not a distinct struct. (should it be?)
- WAY MORE ERROR CHECKING EVERYWHERE (esp in page.go, file manager I was forced to add them more to figure out what was happening)
- make sure page to be written to is fully overwrote
X (DONE) Debug EOF error when reading an unwritten-to block that's after a written-to one


Other stuff - 

Writing to pages is done via a for loop assigning each byte in the input to its corresponding index in the array. There may or may not be a better way to do this using buffers. (As far as I could tell, there were no buffers that had read, write, and seek functionality - at most two of the three.)

The requester must know whether they want an int or bytes; if they ask for bytes when it's an int, it'll interpret that int as the length of the byte-string and potentially cause a lot of problems. This should be fine, I think? 

Up next: 
Debug file manager a little more and add more thorough testing. 
Look at exercises for chapter 3 and decide if any would be helpful to implement. 
Read chapter 6 carefully, and try to implement. 
Optional: Try to add in basics of ch 4 (and maybe 5), if those seem like they'll be incredibly hard to add in later. 


12/31/22 12pm
starting 12pm, with recpage.go (trying to implement ch 6)

todo: 
TEST SCHLAYOUT FUNCS
recordPage is. real tricky without having done the transaction manager
Question - get/set funcs? or no? 
COMMENT EVERYTHINGGGGG
feeling like recpage in particular is a bit too java-like (but I don't understand well enough to fix bc I haven't done ch 3-4 yet) (sigh)
might just need to do those proper, since hard to even test without that 
but hey then there's concurrency! 
need to update go
having duplicate setInt and setString for everything feels... there seems like there should be a better way in Go (esp as you add more types...)
did recordpage just copying, but doing tablescan just with the API and seeing how I do
might need to go back and make a filemanager object
2:30pm checking how well I did with TableScan (feel pretty good, it was mostly transferring over from RecordPage actually?)
can almost certainly switch blknum back from int64 in BlockId sigh
conveniently this author also provides v good tests! 
3:30pm finish ch 6 stuff, at least in theory 
want to implement at least a bit more complexity than in SimpleDB, see problems below / try spanned records maybe? variable length? 
kind of want to just do ch 7 but also kind of should go back and do earlier chapters 
ALSO THEY TRIED TO DELIVER BOOK BUT FAILED FOR UNSPECIFIED REASONS SIGHHHH
okay gonna go back and actually make a FileMgr object 
need to re-test filemanager.go (also fix its problems bc there are a couple sighh)
LOOK AT OS PACKAGE FUNCTION Sync(): Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk. 
(also maybe syscallconn?)
really need to figure out perms for making files
ok done! but untested, and really not sure how pathname for dbDir is gonna work ngl
? how to have testing funcs in each package that aren't technically 'main' - just name test()? ..probs that

TODO:
X fix tests for filemanager.go 
- start filling in memmgr.go 
- comment a bunch of stuff 
- update version of go

4:30pm start tests for filemanager.go 
AND DONE :D 
(except for the weird EOF error from before)
and fixed that! 
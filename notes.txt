
Questions / thoughts: 
Do I need to care about pointers? YUP
How do the driver / sql packages interact with what I need to do? Do I need to implement the functions in driver? 




Package stuff
- sync will be useful for concurrency

Useful tutorial stuff:
https://go.dev/doc/effective_go
https://pkg.go.dev/std standard library
https://go.dev/ref/spec language spec
https://go.dev/doc/tutorial/call-module-code modules / tutorial

Package driver defines interfaces for drivers to implement - probably what I want / equivalent of JDBC? 
https://pkg.go.dev/database/sql/driver@go1.19.4
https://github.com/golang/go/wiki/SQLDrivers
https://pkg.go.dev/database/sql@go1.19.4
https://pkg.go.dev/database/sql@go1.19.4
https://github.com/golang/go/wiki/SQLInterface

for now going for just the block / page things, figure out how to wrap into JDBC-equivalent later 

probs do NOT want syscall bc it's system-specific stuff - os is better

might use unsafe? 

SO on reading and writing bytes - 
I could use a Reader for reading and a Writer for writing but that's creating a reading/writing object each time when I'd rather just have a wrapper for the bytes overall (like java bytebuffer) or access directly via slices (which ... should work?)
Question with slices is how to convert from some bytes to an int ? is there a parseInt for bytes? 
ok yes but I'm still making a reader each time... is that ok? 

something something changing stuff inside functions 
how do I make it so that the write actually sticks? 

APPARENTLY I just needed to give it *Page instead of Page >:( but hey it works now!!

12/21 8pm - Page works, questions remaining:
How to pass blocksize as a constant that you can specify the size of an array with 
How to allow multiple constructors (/ functions) with the same name but different arguments
Is making a [BLOCKSIZE]byte actually a page from the OS? How do I know / trust that? 
Also is blocksize in bits or bytes - 4096 bits or 4096 bytes? 


Important: need to get block / int sizes from single source eventually - how to pull between pages? 
ERROR HANDLING EVERYWHERE
REMEMBER TO CLOSE FILES <- defer thingy?

FIXED: Error - if you write a page to a block in a file, trying to read from any subsequent block which has not been written to results in "Failed to read block in file: EOF" error and then a correct printing of the block contents (i.e. all 0s)
FIXED: EOF error was still returning the empty page that was inserted initially. Now returns both page and err bool. 

Problem: read / write functions are only allowed to be written to/from slices, not arrays, which means my page.contents is currently a slice, which - as far as I can tell is worse? Even though I can set capacity at 4096? 

probably need to reopen vsc in this folder and open old go stuff in a separate window to get it to play nice and not have to use terminal

just declaring everything as int64 rather than int, rather than trying to pull which the computer uses at baseline 

the question of where I go next also kinda depends on how easy it will be to build buffer pools and concurrency in later - if it's a real pain then could just do now? maybe just look at ch 4 / 5 to see how hard implementation would be

12/21 11:30pm SUMMARY--------
Research: 
Go - refresher on basic structs with methods, slices and arrays, syntax, basic maps, pointers. Probably need more work with slices/arrays, and DEFINITELY more with pointers.
Packages - os and io will be vital packages, bytes and encoding/binary are helpful, sync will be important if/when concurrency
DBs/etc - much stronger understanding of the whole filemanager system (of course) as well as exactly how buffers work and interact with files and so on. (I ended up not actually using any buffers really, but I tried for a whiile.)


Coding: 
Created BlockId, Page, and FileManager objects, all of which are (mostly?) functional. 

Struggles: 
- Figuring out how to find the size of int on a particular machine and then deciding to use int64 everywhere rather than having to do some casting for various reasons. 
- Trying very hard to insert a given byte-slice into a particular spot in my byte-array with buffers etc, and eventually just doing it with a for loop through the slice.
- Actually writing to the array and that lasting outside the function requires the method to be on *Page rather than Page so you're changing the actual values, or something. Pointers are bad.  
- Figuring out how to access variables/etc from other files.
- Writing, appending, and reading a file - can't just use Open() for that since you don't get write perms for just that, need to specify in OpenFile() function. 
- A write-to-page operation will not overwrite whatever was on the page previously (or possibly won't overwrite iff it's 0? not sure yet), so need to create new pages each time I want to pull a new thing rather than be able to reuse the same page (which isn't that much of a problem but does seem like it won't work with the buffer pool optimizations)


Later improvements / optimizations / things that are still bad:
- There's only one constructor for Page, and I don't know how to make two functions with the same name that take different arguments. 
- The contents of Page are a slice of capacity blocksize, rather than an array as I'd prefer. There are several constraints here, but one is that the constructor is passing the blocksize but using that as the size of the array is an error because the argument isn't constant. 
- Files closing should use the defer keyword, probably? 
- I don't know what the permission integers mean for when I create/open a file in getFile(), and it's hard-coded
- Page can read/write bytes and integers but should add strings. 
- Testing is ok on page.go but a little messy / uncommented / unclear from cmd line. Testing in filemanager could use serious improvement. 
- I don't understand the format in which it prints numbers by default (i.e. 1029388 is [152 212 125])
- Need to capitalize functions which will be needed outside of this package (and kinda decide how packaging will work / if I want more than one)
X (DONE) Making the initial dbDirectory / how to tell if new for file manager is a little confusing since it's not a distinct struct. (should it be?)
- WAY MORE ERROR CHECKING EVERYWHERE (esp in page.go, file manager I was forced to add them more to figure out what was happening)
- make sure page to be written to is fully overwrote
X (DONE) Debug EOF error when reading an unwritten-to block that's after a written-to one


Other stuff - 

Writing to pages is done via a for loop assigning each byte in the input to its corresponding index in the array. There may or may not be a better way to do this using buffers. (As far as I could tell, there were no buffers that had read, write, and seek functionality - at most two of the three.)

The requester must know whether they want an int or bytes; if they ask for bytes when it's an int, it'll interpret that int as the length of the byte-string and potentially cause a lot of problems. This should be fine, I think? 

Up next: 
Debug file manager a little more and add more thorough testing. 
Look at exercises for chapter 3 and decide if any would be helpful to implement. 
Read chapter 6 carefully, and try to implement. 
Optional: Try to add in basics of ch 4 (and maybe 5), if those seem like they'll be incredibly hard to add in later. 


12/31/22 12pm
starting 12pm, with recpage.go (trying to implement ch 6)

todo: 
TEST SCHLAYOUT FUNCS
recordPage is. real tricky without having done the transaction manager
Question - get/set funcs? or no? 
COMMENT EVERYTHINGGGGG
feeling like recpage in particular is a bit too java-like (but I don't understand well enough to fix bc I haven't done ch 3-4 yet) (sigh)
might just need to do those proper, since hard to even test without that 
but hey then there's concurrency! 
need to update go
having duplicate setInt and setString for everything feels... there seems like there should be a better way in Go (esp as you add more types...)
did recordpage just copying, but doing tablescan just with the API and seeing how I do
might need to go back and make a filemanager object
2:30pm checking how well I did with TableScan (feel pretty good, it was mostly transferring over from RecordPage actually?)
can almost certainly switch blknum back from int64 in BlockId sigh
conveniently this author also provides v good tests! 
3:30pm finish ch 6 stuff, at least in theory 
want to implement at least a bit more complexity than in SimpleDB, see problems below / try spanned records maybe? variable length? 
kind of want to just do ch 7 but also kind of should go back and do earlier chapters 
ALSO THEY TRIED TO DELIVER BOOK BUT FAILED FOR UNSPECIFIED REASONS SIGHHHH
okay gonna go back and actually make a FileMgr object 
need to re-test filemanager.go (also fix its problems bc there are a couple sighh)
LOOK AT OS PACKAGE FUNCTION Sync(): Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk. 
(also maybe syscallconn?)
really need to figure out perms for making files
ok done! but untested, and really not sure how pathname for dbDir is gonna work ngl
? how to have testing funcs in each package that aren't technically 'main' - just name test()? ..probs that

TODO:
X fix tests for filemanager.go 
X start filling in memmgr.go 
- comment a bunch of stuff 
- update version of go
- get simpledb code thingy? 

4:30pm start tests for filemanager.go 
AND DONE :D 
(except for the weird EOF error from before)
and fixed that! 

5pm starting on ch 4 ig 
made addLogPage() func (still can't do func override things)

6pm gotta leave, need to figure out what boundary is but otherwise LogMgr is pretty set


12/31/22 11pm

maybe I should just convert all ints to int64 >:(
12am - finished(?) log manager, I think - still needs testing though
figure out how to do null values for structs? if possible? 
12:30am - first attempt at buffer / buffer manager
this nil stuff is VERY ANNOYING
buffermanager is functional except for:
- the waiting for an open pin thing 
- trying to return either a buffer or nil

feels like FileMgr, LogMgr, BufferMgr shouldn't be structs since there's 1 per db anyway

12/31/22 SUMMARY--------
Progress:
- finished recpage and wrote tableScan as much as I could without ch 4/5 
- made a FileMgr struct from ch 3 (which is probably good, even though it seems maybe too OOP?); fixed tests to work with that (+ fixed EOF error)
- went back to ch 4 (memory management) and did LogMgr, with a decent amount of BufferMgr done as well 

Struggled with: 
- trying to do ch 6 without having ch 4/5 actually done 
- pathname / directory creation stuff (for creating filemgr)
- the append method for LogMgr hurt my head for a while 
- really want to be able to return either struct or nil (or whatever falsy val) but can't, might have to just do errors everywhere? (might be able to just do nil pointers?)
- int vs int64 conversions are annoying 

Questions:
- how do I have test functions (like you'd put in the main() in a java program) that don't run unless I specify (but I can specify that, from cmd line)? 
- Can I return either a falsy value or a struct in a given function? 
- How does waiting / delay stuff work in Go? 
- Is there a difference between creating a [4096]byte vs make([]byte, 4096) in usage / optimization, if I never add more to the slice than that capacity? (If not, can I pass an integer as a constant that can make an array of that size?)
- If I have a [4096]byte, is that / how do I know that that's an actual single page from the OS? 
- What is the sql interface in Go and how do I use it? 

Todo: 
X BufferMgr, waiting functionality 
X BufferMgr, null vs buffer returning (also one in LogMgr too)
X WRITE TESTS for memmgr.go 
X update version of Go 
- actually open the simpledb code 
- read ch 5 carefully

Parking lot: 
- comment EVERYTHING way more 
- way more error checking 
- improve tests
- things to check out: os Sync, syscallconn; io 
- figure out how perms for creating files work
- optimize ch 6 stuff (e.g. spanned records, variable length, etc)
X go back and figure out the string stuff for ch 3
- consider un-struct-ing BufferMgr, LogMgr, FileMgr
- write tests for ch 6 stuff
- make sure that writeBlock actually fully overwrites whatever was on the page previously
- use arrays instead of slices? perhaps? 
- optimize ch 4/5 stuff (only AFTER basics are done tho)
- think about returning vs updating the thing passed in (since returning is probably by value) (but slices are passed by reference!)

bedtime now, more tomorrow! (1:10am, 1/1/23!!)
(or I could stay up looking at the 245 stuff for another 45 minutes) (sigh)
nov 16-21 is NOT gone through (stopped at topic 9, nov 7-14, and some of that is open but not looked through either (struct size, pointers tree, sizeof / array slice size allocations))


1/1/2023 1:15pm
Starting with making tests for logMgr
added get/set string to pages (NEED TO TEST) 
I still don't really understand the maxLength thing for strings on pages - I guess it's basically for different charset encodings. For now leave as is and assume all are ascii (thus all strings must be same length)?
pointers sigh
need WAYYY better test print thingies that actually say what each part is doing (also tbf, have the prints for inside the Page stuff be tested there, so it doesn't clutter up tests of eg logmgr)
having append be pointer makes currblock stay 
writing (reading?) SPECIFICALLY block 0 fails
write works and reads correctly inside flush but not outside
why is everything doubled when it gets written down in binary (or maybe just ints?)

5:30pm still struggling with error above: the writing of block 0 to the file (via flush) is local and does not survive outside the scope. Writing and reading any blocks 1+ does not have this problem and saves pages to the file perfectly fine. 

6:30pm 
FIXED - turned out to be a problem in fileMgr.appendNewBlock() where it was doing Write(b) and overwriting the first block as empty post-writing (or something? still not super clear but changing to f.WriteAt worked)

Had temporary error where on creating log files 0-10, they'd print fine, and then creating additionaly 36-70, the print would work for the first several(?) records (i.e. 170, 169, ...) but somewhere in the middle (like around 155) the prints would only happen for every other record, and skip the rest. Can't recreate now, so hopefully it's fine? 

Dinnertime now (6:45); next up is BufferMgr (but since I did a LOT of debugging / work with Page and FileMgr, that shoulddd be a smoother ride as long as I look over it again really carefully before trying any tests.)
TODO: add test thingies in where appropriate; for now I'm gonna delete all my print statements bc they took up half the thing -> meant that for log manager but it also applies to filemgr

8:45 
separating buffermgr into different file because I should have done that from the start 
Ordering for BM: check code against book code, fix nil nonsense, write out book tests, debug book tests. Maybe look into how wait() works 
I read some bits of the Go book and concluded mostly that I should be using a lot more pointers, which is fun
(something like "convention dictates if one method for a struct/whatever takes a pointer, they all should")

1/2/23 12pm
Going to start with an attempt to convert things into pointers, because doing it later will just be way more frustrating 
12:20 done! seemed to work fine?? the worst thing about pointers is how you can use them in multiple ways, esp. that * means multiple things depending on context (or something, idk)
Next, buffer manager! gonna read carefully and fix nil things 
Okay 1) I dont' think I need to make the Buffer methods take a pointer to a buffer since none of them (except the constructor) are doing anything, just modifying the buffer put in. right? update: after reading book, no. do not. But you don't have to change stuff wherever buffer methods are used because Go implicitly takes the address ...that probably means pointering BM too -> also filemgr I think
2) I CAN RETURN NIL VALUES NOW so.... it might be ok? 
12:45 ignoring the wait part for now (calling panic, which is maybe not the best plan but it's fine) to do testing
had error because the BM wasn't actually taking the pool I made in the constructor and using it
buffer pool is now a slice of POINTERS to buffers. is that better? I feel like it works? when I tried to print bm.bufferpool (with non-pointer values), it printed the 0 values
buffer tests work 
changing read block to NOT return a page
adding defer keywords to file closings 
making blockId constructor (that actually adds a new block at the end if you need to extend the file)

3pm BufferMgr tests appear to work!! (And so do the Buffer tests!) ALSO I GOT THE TEXTBOOK!!
I think that means chapter 4 is done???
Okay the 'wait' method isn't with concurrency like it should be 
so ch 4 todo:
- do threading / concurrency for chooseUnpinnedBuffer() waiting on unpinned buffers by checking after something is unpinned, not just every X seconds 
- change chooseUnpinnedBuffer strategy to the clock one (i.e. start looking at the buffer directly after the most currently used instead of at the beginning)
- add better test prints / have a testing flag / maybe just have better tests in general 
- check on pointer things (more)
- comments

end of ch 4 problems notes: 
- 4.4 / 4.15 suggests looking for an unmodified buffer over a modified one when pinning something new. Disadvantage is you might have to read the old one again (and that's potentially more likely than having to read an already-modified block that just needs to be written back), BUT advantage is that you don't actually have to do a write to the disk! Which seems worth it? 
- 4.11 (use buffer for the logPage), 4.12 (use buffer to hold the next() pages in iterator), 4.17 (make the pool a different data structure(s) to allow easier searching through buffers), and maybe 4.18 (make a way for BM to print usage statistics) seem good 

5:15 finished reading ch 5
Conclusion: unlike last chapter, this one actually would be relatively easy to come back later and fill in, so long as I have a Transaction object. I might do the recovery part but DEFINITELY not the concurrency yet. no thank you. 
starting with making BufferList and I just realized that anonymous structs would be really nice here because I wouldn't have to do like bl.bm.lm or anything but could just do bl.thefunc - todo, but later
also possibly pick something different for constructors, maybe newWhatever
Noticing again that setInt vs setString seem to be... very duplicating each other 
6:00 done with writing out Transaction & BufferList classes without including any recovery / concurrency. now to test
should there be a db object? ... okay yes almost definitely. do that later (but soonish)
maybe haven't had as many passing problems as expected because slices are pointers? 
look at p 86-87 of go book, and consider equality things (prooobably okay generally because we actually want to be passing pointers?)

okay so the pins list in BufferList is giving me some trouble - it's a list where each item is a buffer that is pinned, and if you pin again you add a duplicate to the list 
I need to be able to:
- look whether a particular buffer exists AND remove it (once)
arraylists can do both of these (the .remove() function exists), but slices in go would have to loop through to find if something exists and return the index (which is doable), OR maps in go can find existence, but removing exactly one each time is a little more of a pain
Could make a pins map (v duplicated)
Could combine pins and buffers - is that a good idea? 
going with pins map, whatever

6:45
okay ACTUALLY finished all the pre-test debugging now. food time. 

8:45 came back from dinner (in which I read the Go book chapter 1, because of course) and wrote and tested tests! 

10:15
Tests completed and work, insofar as they do what they're supposed to. Both recovery and concurrency are not implemented at all, and probably won't be for a while (though recovery is doable / would be nice so the log file is useful)

1/3/23 9:15pm 
Did a bit of work earlier copying record page test from book, now actually trying to test that and make it work. Schema/Layout is good as far as I can tell. 
Consider putting all types in a separate 'definitions' file so I can remember them easier? 
Question - should I be leaving the first 8 bytes of a block for the buffer/etc managers to use and preclude records? How should I do that / why is it not happening already (something about Java?)
stopping 9:55 for val


1/4/23 3pm
Did I ever deal with the thing about offsets? I suspect that's why only every other slot is being filled - it needs padding at the end, but I'm not really sure even how to check that (I just remember that Java does it automatically so Sciore doesn't need to care)
Regardless, recordPage tests look good except for that, and it's not like filling in odd slots and not telling - it's only filling every other. 
Changing methods for RecordPage and TableScan to be methods on pointers. Probably for the best? It may be that makeRecordPage should also return a pointer, not sure yet. 
I added a "make new block if you can't find the one you're trying to pin" condition in buffermgr (in assignToBlock), but I'm not sure where that should be / readBlock still prints an error / need to be more careful/thoughtful about where that should go and why. 


4:15pm
TableScanTest now works! Except that in addition to only entering records in even-numbered slots, it's also skipping even-numbered blocks! I.... do not know why. 
I'd also still love to know why printing these bytes doubles every(?) value - at least every int value? e.g. if I set a particular byte to have the value 2, it will print as 4. 
Problem appears to be that when it tries to create the table, it sees there's already a file with blocks in it, so it just goes to the first block to start reading - but the first block isn't actually formatted so it can't see that it's empty (tbf, will be better if/when I switch the EMPTY flag back to 0) and so doesn't get anything until it appends a new block. 
Fix: Layout wasn't calculating offsets properly, because it wasn't taking into account the integer at the front of a string that says its length. Sigh. 
I made some changes in the process of this that I am very much uncertain about, so that's fun. 
